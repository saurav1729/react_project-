// Code Generated by Sidekick is for learning and experimentation purposes only.
import asyncHandler from "../utils/asyncHandler";
import ApiError from "../utils/apiError";
import APIFilters from "../utils/apiFilter";
import mongoose from "mongoose";

import TicketModel from "../models/Ticket";
import TicketAgentDecisionModel from "../models/TicketAgentDecision";
import * as ticketService from "../services/ticket.service";
import { getTicketStats as getTicketStatsService } from "../services/ticket.service"; // Direct import to avoid namespace issues
import { TICKET_STATUS, USER_ROLES } from "../utils/constants";

function applySearchOverride<T>(baseQuery: any, q: any) {
  const qu = String(q || "").trim();
  if (!qu) return baseQuery;

  const isDisplayId = /^[A-Z]{2,5}-\d{1,10}$/i.test(qu);
  if (isDisplayId) return baseQuery.find({ displayId: qu.toUpperCase() });

  return baseQuery;
}

export const createTicket = asyncHandler(async (req: any, res) => {
  console.log(req.body);
  // Allow both Requesters and Agents to create tickets
  if (req.user?.role !== USER_ROLES.REQUESTER && req.user?.role !== USER_ROLES.AGENT) {
    throw new ApiError(403, "Only Requesters or Agents can create tickets", "FORBIDDEN");
  }

  const ticket = await ticketService.createTicket({
    requesterId: req.user._id,
    body: req.body,
    files: req.files as Express.Multer.File[] | undefined
  });

  res.status(201).json({ success: true, message: "Ticket created", data: ticket });
});

export const getTicketDetail = asyncHandler(async (req: any, res) => {
  const ticket = await ticketService.getTicketDetail({ user: req.user, ticketId: req.params.id });
  res.status(200).json({ success: true, data: ticket });
});

export const history = asyncHandler(async (req, res) => {
  const events = await ticketService.listAuditEvents({ user: req.user, ticketId: req.params.id });
  res.status(200).json({ success: true, results: events.length, data: events });
});

export const getMyTickets = asyncHandler(async (req: any, res) => {
  // Allow Agents to see tickets they created/requested
  if (req.user?.role !== USER_ROLES.REQUESTER && req.user?.role !== USER_ROLES.AGENT) {
    throw new ApiError(403, "Forbidden", "FORBIDDEN");
  }

  let baseQuery: any = TicketModel.find({ requesterId: req.user._id })
    .populate("categoryId", "name")
    .populate("assigneeId", "firstName lastName email");
  baseQuery = applySearchOverride(baseQuery, req.query.q);

  const apiFilters = new APIFilters(baseQuery, req.query, { defaultSort: "-updatedAt" })
    .filter()
    .sort()
    .limitFields()
    .searchByQuery(true)
    .pagination();

  const countQuery: any = TicketModel.find({ requesterId: req.user._id });
  const countFilters = new APIFilters(countQuery, req.query, { defaultSort: "-updatedAt" })
    .filter()
    .searchByQuery(true);

  const [tickets, total] = await Promise.all([apiFilters.query, (countFilters.query as any).countDocuments()]);

  res.status(200).json({
    success: true,
    results: tickets.length,
    meta: apiFilters.getMeta(total),
    data: tickets
  });
});

export const getAgentAssignedTickets = asyncHandler(async (req: any, res) => {
  if (req.user?.role !== USER_ROLES.AGENT) throw new ApiError(403, "Forbidden", "FORBIDDEN");

  const query: any = { assigneeId: req.user._id };

  if (req.query.q) {
    const qu = String(req.query.q).trim();
    if (qu) {
      const isDisplayId = /^[A-Z]{2,5}-\d{1,10}$/i.test(qu);
      if (isDisplayId) {
        query.displayId = qu.toUpperCase();
      } else {
        query.$or = [
          { title: { $regex: qu, $options: 'i' } },
          { description: { $regex: qu, $options: 'i' } },
          { displayId: { $regex: qu, $options: 'i' } }
        ];
      }
    }
  }

  let baseQuery: any = TicketModel.find(query)
    .populate("categoryId", "name")
    .populate("requesterId", "firstName lastName email");

  // We handle 'q' manually above, so we don't need applySearchOverride or searchByQuery
  const apiFilters = new APIFilters(baseQuery, req.query, { defaultSort: "-updatedAt" })
    .filter()
    .sort()
    .limitFields()
    .pagination();

  // For countQuery, we need same filters
  const countQuery: any = TicketModel.find(query);
  const countFilters = new APIFilters(countQuery, req.query, { defaultSort: "-updatedAt" })
    .filter();

  // Note: APIFilters.filter() removes 'q' from filter params, so it won't interfere.
  // We already applied 'q' to the 'query' object passed to find().

  const [tickets, total] = await Promise.all([apiFilters.query, (countFilters.query as any).countDocuments()]);

  res.status(200).json({
    success: true,
    results: tickets.length,
    meta: apiFilters.getMeta(total),
    data: tickets
  });
});

export const getAgentUnassignedTickets = asyncHandler(async (req: any, res) => {
  if (req.user?.role !== USER_ROLES.AGENT) throw new ApiError(403, "Forbidden", "FORBIDDEN");

  // Mandatory: Created + assigneeId null; Exclude: rejected-by-agent
  const { requiredMatch, rejectedIds } = await ticketService.buildUnassignedConstraintsForAgent(req.user._id);

  const matchStage = {
    $match: {
      ...requiredMatch,
      _id: { $nin: rejectedIds }
    }
  };

  // Search filter
  if (req.query.q) {
    const qu = String(req.query.q).trim();
    if (qu) {
      // Simple regex search or text search. APIFilters used text search.
      // Let's use regex for title/description comparison or match displayId if it looks like one.
      const isDisplayId = /^[A-Z]{2,5}-\d{1,10}$/i.test(qu);
      if (isDisplayId) {
        (matchStage.$match as any).displayId = qu.toUpperCase();
      } else {
        (matchStage.$match as any).$or = [
          { title: { $regex: qu, $options: 'i' } },
          { description: { $regex: qu, $options: 'i' } },
          { displayId: { $regex: qu, $options: 'i' } }
        ];
      }
    }
  }

  // Filter by category if provided
  if (req.query.categoryId) {
    (matchStage.$match as any).categoryId = new mongoose.Types.ObjectId(String(req.query.categoryId));
  }
  if (req.query.priority) {
    (matchStage.$match as any).priority = req.query.priority;
  }
  if (req.query.type) {
    (matchStage.$match as any).type = req.query.type;
  }

  const page = parseInt(String(req.query.page || "1"), 10) || 1;
  const limit = parseInt(String(req.query.limit || "10"), 10) || 10;
  const skip = (page - 1) * limit;

  const pipeline: any[] = [
    matchStage,
    {
      $addFields: {
        priorityWeight: {
          $switch: {
            branches: [
              { case: { $eq: ["$priority", "Critical"] }, then: 4 },
              { case: { $eq: ["$priority", "High"] }, then: 3 },
              { case: { $eq: ["$priority", "Medium"] }, then: 2 },
              { case: { $eq: ["$priority", "Low"] }, then: 1 }
            ],
            default: 0
          }
        }
      }
    },
    {
      $sort: { priorityWeight: -1, createdAt: 1 } // Highest priority first, then oldest first
    },
    {
      $facet: {
        metadata: [{ $count: "total" }],
        data: [
          { $skip: skip },
          { $limit: limit },
          // Lookup Category
          {
            $lookup: {
              from: "categories",
              localField: "categoryId",
              foreignField: "_id",
              as: "category"
            }
          },
          { $unwind: { path: "$category", preserveNullAndEmptyArrays: true } },
          // Lookup Requester
          {
            $lookup: {
              from: "users",
              localField: "requesterId",
              foreignField: "_id",
              as: "requester"
            }
          },
          { $unwind: { path: "$requester", preserveNullAndEmptyArrays: true } },
          // Project to match expected output structure
          {
            $project: {
              _id: 1,
              displayId: 1,
              title: 1,
              description: 1,
              type: 1,
              priority: 1,
              status: 1,
              deviceType: 1,
              operatingSystem: 1,
              location: 1,
              createdAt: 1,
              updatedAt: 1,
              // Flattened/Projected lookups
              category: { _id: "$category._id", name: "$category.name" },
              requesterId: {
                _id: "$requester._id",
                firstName: "$requester.firstName",
                lastName: "$requester.lastName",
                email: "$requester.email"
              }
            }
          }
        ]
      }
    }
  ];

  const result = await TicketModel.aggregate(pipeline);

  const facetResult = result[0];
  const total = facetResult.metadata[0] ? facetResult.metadata[0].total : 0;
  const tickets = facetResult.data;
  const pages = Math.max(1, Math.ceil(total / limit));

  res.status(200).json({
    success: true,
    results: tickets.length,
    meta: { page, limit, pages, total },
    data: tickets
  });
});

export const claim = asyncHandler(async (req: any, res) => {
  const ticket = await ticketService.claimTicket({ agentId: req.user!._id, ticketId: req.params.id });
  res.status(200).json({ success: true, message: "Ticket claimed", data: ticket });
});

export const start = asyncHandler(async (req: any, res) => {
  const ticket = await ticketService.startTicket({ agentId: req.user!._id, ticketId: req.params.id });
  res.status(200).json({ success: true, message: "Ticket started", data: ticket });
});

export const unassign = asyncHandler(async (req: any, res) => {
  const ticket = await ticketService.unassignTicket({
    agentId: req.user!._id,
    ticketId: req.params.id,
    reason: req.body.reason
  });
  res.status(200).json({ success: true, message: "Ticket unassigned", data: ticket });
});

export const complete = asyncHandler(async (req: any, res) => {
  const ticket = await ticketService.completeTicket({
    agentId: req.user!._id,
    ticketId: req.params.id,
    resolutionSummary: req.body.resolutionSummary
  });
  res.status(200).json({ success: true, message: "Ticket completed", data: ticket });
});

export const reopen = asyncHandler(async (req: any, res) => {
  const ticket = await ticketService.reopenTicket({
    agentId: req.user!._id,
    ticketId: req.params.id
  });
  res.status(200).json({ success: true, message: "Ticket reopened", data: ticket });
});

export const reject = asyncHandler(async (req: any, res) => {
  const decision = await ticketService.rejectUnassignedTicket({
    agentId: req.user!._id,
    ticketId: req.params.id,
    reason: req.body.reason
  });
  res.status(200).json({ success: true, message: "Ticket rejected", data: decision });
});

export const getTicketStats = asyncHandler(async (req: any, res) => {
  const stats = await getTicketStatsService({ userId: req.user!._id, role: req.user!.role });
  res.status(200).json({ success: true, data: stats });
});
// ... existing imports

export const getAllTickets = asyncHandler(async (req: any, res) => {
  if (req.user?.role !== USER_ROLES.AGENT) {
    throw new ApiError(403, "Forbidden", "FORBIDDEN");
  }

  const query: any = {};

  if (req.query.q) {
    const qu = String(req.query.q).trim();
    if (qu) {
      const isDisplayId = /^[A-Z]{2,5}-\d{1,10}$/i.test(qu);
      if (isDisplayId) {
        query.displayId = qu.toUpperCase();
      } else {
        query.$or = [
          { title: { $regex: qu, $options: 'i' } },
          { description: { $regex: qu, $options: 'i' } },
          { displayId: { $regex: qu, $options: 'i' } }
        ];
      }
    }
  }

  let baseQuery: any = TicketModel.find(query)
    .populate("categoryId", "name")
    .populate("requesterId", "firstName lastName email")
    .populate("assigneeId", "firstName lastName email");

  const apiFilters = new APIFilters(baseQuery, req.query, { defaultSort: "-updatedAt" })
    .filter()
    .sort()
    .limitFields()
    .pagination();

  const countQuery: any = TicketModel.find(query);
  const countFilters = new APIFilters(countQuery, req.query, { defaultSort: "-updatedAt" })
    .filter();

  const [tickets, total] = await Promise.all([apiFilters.query, (countFilters.query as any).countDocuments()]);

  res.status(200).json({
    success: true,
    results: tickets.length,
    meta: apiFilters.getMeta(total),
    data: tickets
  });
});
