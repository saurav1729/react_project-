// Code Generated by Sidekick is for learning and experimentation purposes only.
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import env from "../config/env";
import ApiError from "../utils/apiError";
import UserModel, { type IUser } from "../models/User";

function signToken(userId: string) {
  return jwt.sign({ sub: userId }, env.JWT_SECRET, { expiresIn: env.JWT_EXPIRES_IN });
}

export async function register(payload: { firstName: string; lastName: string; email: string; password: string }) {
  const email = payload.email.toLowerCase();
  const exists = await UserModel.findOne({ email });
  if (exists) throw new ApiError(409, "Email already in use", "DUPLICATE_EMAIL");

  const passwordHash = await bcrypt.hash(payload.password, 12);

  const user = await UserModel.create({
    firstName: payload.firstName,
    lastName: payload.lastName,
    email,
    passwordHash
    // role defaults to Requester
  });

  const token = signToken(String(user._id));
  const safeUser = (await UserModel.findById(user._id).select("-passwordHash")) as IUser | null;

  return { user: safeUser, token };
}

export async function login(payload: { email: string; password: string }) {
  const email = payload.email.toLowerCase();
  const user = await UserModel.findOne({ email });
  if (!user || !user.isActive) throw new ApiError(401, "Invalid credentials", "INVALID_CREDENTIALS");

  const ok = await bcrypt.compare(payload.password, user.passwordHash);
  if (!ok) throw new ApiError(401, "Invalid credentials", "INVALID_CREDENTIALS");

  user.lastLoginAt = new Date();
  await user.save();

  const token = signToken(String(user._id));
  const safeUser = await UserModel.findById(user._id).select("-passwordHash");

  return { user: safeUser, token };
}
