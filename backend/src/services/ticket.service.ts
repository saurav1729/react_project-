// Code Generated by Sidekick is for learning and experimentation purposes only.
import ApiError from "../utils/apiError";
import TicketModel from "../models/Ticket";
import CounterModel from "../models/Counter";
import AuditEventModel from "../models/AuditEvent";
import TicketAgentDecisionModel from "../models/TicketAgentDecision";
import { createMany as createAttachments } from "./attachment.service";
import {
  AUDIT_EVENT_TYPE,
  AUDIT_VISIBILITY,
  TICKET_STATUS,
  USER_ROLES
} from "../utils/constants";

export async function createTicket(params: {
  requesterId: any;
  body: any;
  files?: Express.Multer.File[];
}) {
  const { requesterId, body, files } = params;

  // Handle Category Name lookup if categoryId is missing but categoryName is present
  if (!body.categoryId && body.categoryName) {
    const CategoryModel = require("../models/Category").default; // Dynamic import to avoid circular dependency if any, or just import at top
    const category = await CategoryModel.findOne({ name: body.categoryName });
    if (category) {
      body.categoryId = category._id;
    } else {
      // Option: Create it? Or throw error? User said "refine wherever is required... pass the name... it will use refine". 
      // Let's create it if it doesn't exist to be safe/robust, or just start with error if strict.
      // Given "fixed categories", let's assume they might not exist yet in empty DB, so maybe create? 
      // Actually, user said "there will always be 4 categories", so better to find or throw. 
      // But for "refine the backend", auto-creation/finding is standard.
      // Let's throw for now as they are "fixed".
      throw new ApiError(400, `Category '${body.categoryName}' not found`, "BAD_REQUEST");
    }
  }

  // 1) Next display ID (no transactions on standalone MongoDB)
  const counter = await CounterModel.findByIdAndUpdate(
    "INC",
    { $inc: { seq: 1 } },
    { new: true, upsert: true, setDefaultsOnInsert: true }
  );

  const n = String(counter!.seq).padStart(3, "0");
  const displayId = `INC-${n}`;

  // 2) Create ticket
  const created = await TicketModel.create({
    displayId,
    requesterId,
    ...body,
    status: TICKET_STATUS.CREATED,
    assigneeId: null
  });

  // 3) Audit event
  await AuditEventModel.create({
    ticketId: created._id,
    actorId: requesterId,
    eventType: AUDIT_EVENT_TYPE.TICKET_CREATED,
    visibility: AUDIT_VISIBILITY.PUBLIC,
    metadata: { displayId }
  });

  // 4) Attachments (+ audit)
  const attachments = await createAttachments({
    files,
    ticketId: created._id,
    commentId: null,
    uploadedBy: requesterId
  });

  if (attachments.length) {
    await AuditEventModel.create(
      attachments.map(() => ({
        ticketId: created._id,
        actorId: requesterId,
        eventType: AUDIT_EVENT_TYPE.ATTACHMENT_ADDED,
        visibility: AUDIT_VISIBILITY.PUBLIC
      }))
    );
  }

  return created;
}

function buildTicketAccessQuery(params: { user: any; ticketId: any }) {
  const { user, ticketId } = params;
  if (user.role === USER_ROLES.AGENT) return { _id: ticketId };
  return { _id: ticketId, requesterId: user._id };
}

export async function getTicketDetail(params: { user: any; ticketId: any }) {
  const { user, ticketId } = params;

  const ticket = await TicketModel.findOne(buildTicketAccessQuery({ user, ticketId }))
    .populate("requesterId", "firstName lastName email role")
    .populate("assigneeId", "firstName lastName email role")
    .populate("categoryId", "name");

  if (!ticket) throw new ApiError(404, "Ticket not found", "NOT_FOUND");
  return ticket;
}

export async function claimTicket(params: { agentId: any; ticketId: any }) {
  const { agentId, ticketId } = params;
  const now = new Date();

  // Edge case: Agents cannot claim their own tickets
  const ticket = await TicketModel.findById(ticketId).select("requesterId");
  if (ticket && String(ticket.requesterId) === String(agentId)) {
    throw new ApiError(409, "Cannot assign your own ticket", "CONFLICT");
  }

  const updated = await TicketModel.findOneAndUpdate(
    { _id: ticketId, status: TICKET_STATUS.CREATED, assigneeId: null },
    { $set: { assigneeId: agentId, status: TICKET_STATUS.ASSIGNED, assignedAt: now, updatedAt: now } },
    { new: true, runValidators: true }
  )
    .populate("requesterId", "firstName lastName email role")
    .populate("assigneeId", "firstName lastName email role")
    .populate("categoryId", "name");

  if (!updated) throw new ApiError(409, "Ticket already claimed or not claimable", "CONFLICT");

  await AuditEventModel.create({
    ticketId,
    actorId: agentId,
    eventType: AUDIT_EVENT_TYPE.ASSIGNED,
    visibility: AUDIT_VISIBILITY.PUBLIC,
    from: { assigneeId: null, status: TICKET_STATUS.CREATED },
    to: { assigneeId: agentId, status: TICKET_STATUS.ASSIGNED }
  });

  return updated;
}

export async function startTicket(params: { agentId: any; ticketId: any }) {
  const { agentId, ticketId } = params;
  const now = new Date();

  const updated = await TicketModel.findOneAndUpdate(
    { _id: ticketId, assigneeId: agentId, status: TICKET_STATUS.ASSIGNED },
    { $set: { status: TICKET_STATUS.STARTED, startedAt: now, updatedAt: now } },
    { new: true, runValidators: true }
  )
    .populate("requesterId", "firstName lastName email role")
    .populate("assigneeId", "firstName lastName email role")
    .populate("categoryId", "name");

  if (!updated) throw new ApiError(409, "Ticket not in Assigned state", "CONFLICT");

  await AuditEventModel.create({
    ticketId,
    actorId: agentId,
    eventType: AUDIT_EVENT_TYPE.STARTED,
    visibility: AUDIT_VISIBILITY.PUBLIC,
    from: { status: TICKET_STATUS.ASSIGNED },
    to: { status: TICKET_STATUS.STARTED }
  });

  return updated;
}

export async function unassignTicket(params: { agentId: any; ticketId: any; reason: string }) {
  const { agentId, ticketId, reason } = params;
  const now = new Date();

  const updated = await TicketModel.findOneAndUpdate(
    { _id: ticketId, assigneeId: agentId, status: { $in: [TICKET_STATUS.ASSIGNED, TICKET_STATUS.STARTED] } },
    {
      $set: {
        assigneeId: null,
        status: TICKET_STATUS.CREATED,
        assignedAt: null,
        startedAt: null,
        updatedAt: now
      }
    },
    { new: true, runValidators: true }
  )
    .populate("requesterId", "firstName lastName email role")
    .populate("assigneeId", "firstName lastName email role")
    .populate("categoryId", "name");

  if (!updated) throw new ApiError(409, "Ticket not unassignable", "CONFLICT");

  await AuditEventModel.create({
    ticketId,
    actorId: agentId,
    eventType: AUDIT_EVENT_TYPE.UNASSIGNED,
    visibility: AUDIT_VISIBILITY.PUBLIC,
    from: { assigneeId: agentId },
    to: { assigneeId: null },
    metadata: { reason }
  });

  return updated;
}

export async function completeTicket(params: {
  agentId: any;
  ticketId: any;
  resolutionSummary: string;
}) {
  const { agentId, ticketId, resolutionSummary } = params;
  const now = new Date();

  const updated = await TicketModel.findOneAndUpdate(
    { _id: ticketId, assigneeId: agentId, status: { $in: [TICKET_STATUS.ASSIGNED, TICKET_STATUS.STARTED] } },
    { $set: { status: TICKET_STATUS.COMPLETED, resolutionSummary, completedAt: now, updatedAt: now } },
    { new: true, runValidators: true }
  )
    .populate("requesterId", "firstName lastName email role")
    .populate("assigneeId", "firstName lastName email role")
    .populate("categoryId", "name");

  if (!updated) throw new ApiError(409, "Ticket not completable", "CONFLICT");

  await AuditEventModel.create({
    ticketId,
    actorId: agentId,
    eventType: AUDIT_EVENT_TYPE.COMPLETED,
    visibility: AUDIT_VISIBILITY.PUBLIC,
    metadata: { resolutionSummary }
  });

  return updated;
}

export async function reopenTicket(params: { agentId: any; ticketId: any }) {
  const { agentId, ticketId } = params;
  const now = new Date();

  // Ensure ticket is Completed and agent is the assignee
  // Or check if ticket allows reopening by assignee
  const updated = await TicketModel.findOneAndUpdate(
    { _id: ticketId, assigneeId: agentId, status: TICKET_STATUS.COMPLETED },
    {
      $set: {
        status: TICKET_STATUS.ASSIGNED,
        updatedAt: now,
        // Optional: clear completedAt? Usually keep it as record of previous completion, or clear it.
        // Let's clear it to indicate it's open again.
        completedAt: null
      }
    },
    { new: true, runValidators: true }
  )
    .populate("requesterId", "firstName lastName email role")
    .populate("assigneeId", "firstName lastName email role")
    .populate("categoryId", "name");

  if (!updated) throw new ApiError(409, "Ticket cannot be reopened (must be Completed and owned by you)", "CONFLICT");

  await AuditEventModel.create({
    ticketId,
    actorId: agentId,
    eventType: AUDIT_EVENT_TYPE.REOPENED, // Ensure this constant exists or use string "TICKET_REOPENED"
    visibility: AUDIT_VISIBILITY.PUBLIC,
    from: { status: TICKET_STATUS.COMPLETED },
    to: { status: TICKET_STATUS.ASSIGNED }
  });

  return updated;
}

export async function rejectUnassignedTicket(params: { agentId: any; ticketId: any; reason?: string }) {
  const { agentId, ticketId, reason } = params;

  const ticket = await TicketModel.findById(ticketId).select("_id status assigneeId");
  if (!ticket) throw new ApiError(404, "Ticket not found", "NOT_FOUND");

  if (!(ticket.status === TICKET_STATUS.CREATED && ticket.assigneeId === null)) {
    throw new ApiError(409, "Only unassigned tickets can be rejected", "CONFLICT");
  }

  const doc = await TicketAgentDecisionModel.findOneAndUpdate(
    { ticketId, agentId },
    { $set: { decision: "Rejected", reason: reason || undefined, decidedAt: new Date() } },
    { new: true, upsert: true, setDefaultsOnInsert: true }
  );

  await AuditEventModel.create({
    ticketId,
    actorId: agentId,
    eventType: AUDIT_EVENT_TYPE.REJECTED_BY_AGENT,
    visibility: AUDIT_VISIBILITY.INTERNAL,
    metadata: { reason: reason || null }
  });

  return doc;
}

export async function listAuditEvents(params: { user: any; ticketId: any }) {
  const { user, ticketId } = params;
  const query: any = { ticketId };

  if (user.role !== USER_ROLES.AGENT) query.visibility = AUDIT_VISIBILITY.PUBLIC;

  return AuditEventModel.find(query).sort({ occurredAt: 1 }).populate("actorId", "firstName lastName email role");
}

/**
 * Used by agent "Unassigned Tickets" list:
 * mandatory: status=Created and assigneeId=null
 * exclude: tickets rejected by this agent
 */
export async function buildUnassignedConstraintsForAgent(agentId: any) {
  const rejected = await TicketAgentDecisionModel.find({ agentId, decision: "Rejected" }).select("ticketId");
  const rejectedIds = rejected.map((r) => r.ticketId);

  return {
    requiredMatch: { status: TICKET_STATUS.CREATED, assigneeId: null } as const,
    rejectedIds
  };
}

export async function getTicketStats(params: { userId: any; role: string }) {
  const { userId, role } = params;
  const match: any = {};

  if (role === USER_ROLES.REQUESTER) {
    match.requesterId = userId;
  } else if (role === USER_ROLES.AGENT) {
    // For agents, 'My Tickets' usually means assigned to them
    match.assigneeId = userId;
  }

  const [total, unassigned, assigned, completed] = await Promise.all([
    // All
    TicketModel.countDocuments(match),
    // Unassigned (Created)
    TicketModel.countDocuments({ ...match, status: TICKET_STATUS.CREATED }),
    // Assigned (Assigned/Started)
    TicketModel.countDocuments({ ...match, status: { $in: [TICKET_STATUS.ASSIGNED, TICKET_STATUS.STARTED] } }),
    // Completed
    TicketModel.countDocuments({ ...match, status: TICKET_STATUS.COMPLETED })
  ]);

  return {
    total,
    unassigned,
    assigned,
    completed
  };
}
